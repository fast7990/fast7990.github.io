<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>è¯­éŸ³è¯†åˆ« Demo</title>
    <style>
        /* è‡ªåŠ¨æ»šåŠ¨çš„ç»“æœæ¡†æ ·å¼ */
        #result {
            margin-top: 20px;
            width: 100%;
            height: 400px;            /* å¯æ ¹æ®éœ€è¦è°ƒæ•´é«˜åº¦ */
            overflow-y: auto;         /* è¶…å‡ºæ—¶æ˜¾ç¤ºæ»šåŠ¨æ¡ */
            white-space: pre-wrap;    /* ä¿ç•™æ¢è¡Œ */
            padding: 8px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: monospace;   /* ç­‰å®½å­—ä½“ï¼Œæ›´æ˜“é˜…è¯» */
        }
    </style>
</head>
<body>

<h2>åŸºç¡€å‚æ•°</h2>
<label>tokenï¼š</label>
<input type="text" id="token" value="">
<br><br>
<label>userIdï¼š</label>
<input type="text" id="userId" value="">
<br><br>
<label>è¯†åˆ«è¯­è¨€ï¼š</label>
<select id="languageSelect" style="width: 200px;">
    <option value="zh-Hans-CN">ä¸­æ–‡ç®€ä½“-æ™®é€šè¯</option>
    <option value="en-US">English (US)</option>
    <option value="es-ES">EspaÃ±ol</option>
    <option value="fr-FR">FranÃ§ais</option>
    <option value="de-DE">Deutsch</option>
    <option value="it-IT">Italiano</option>
    <option value="ko-KR">í•œêµ­ì–´</option>
    <option value="ja-JP">æ—¥æœ¬èª</option>
</select><br><br>
<hr/>
<h2>ğŸ™ï¸ å®æ—¶è¯­éŸ³è¯†åˆ«</h2>
<br>

<label>è¯†åˆ«ç±»å‹ï¼š</label>
<select id="transcribe_type" style="width: 200px;">
    <option value="realtime">å®æ—¶è¯†åˆ«</option>
    <option value="one_sentence">ä¸€å¥è¯è¯†åˆ«</option>
</select>
<br><br>

<label>å¯ç”¨ç¿»è¯‘ï¼š</label>
<input type="checkbox" id="enableRealtimeTranslator">
<br><br>

<label>ç¿»è¯‘åˆ°ç›®æ ‡è¯­è¨€ï¼š</label>
<select id="realtimeTranslatorTarget" style="width: 200px;">
    <option value="zh-CN">ä¸­æ–‡ç®€ä½“-æ™®é€šè¯</option>
    <option value="en-US">English (US)</option>
    <option value="es-ES">EspaÃ±ol</option>
    <option value="fr-FR">FranÃ§ais</option>
    <option value="de-DE">Deutsch</option>
    <option value="it-IT">Italiano</option>
    <option value="ko-KR">í•œêµ­ì–´</option>
    <option value="ja-JP">æ—¥æœ¬èª</option>
</select>
<br><br>

<button id="btnStart">ğŸ¤ å¼€å§‹è¯†åˆ«</button>
<button id="btnStop">ğŸ¤ åœæ­¢è¯†åˆ«</button>

<!-- è‡ªåŠ¨æ»šåŠ¨çš„ç»“æœæ¡† -->
<div id="result"></div>

<hr/>

<script>
    let ws;
    let audioChunks = [];
    const FRAMES_PER_SECOND = 25;

    // é¡µé¢åŠ è½½ï¼šè¯»å–å¹¶å¡«å…… tokenï¼Œç»‘å®šç¼“å­˜æ›´æ–°
    window.onload = function () {
        const tokenInput = document.getElementById("token");
        // å¦‚æœæœ¬åœ°æœ‰ç¼“å­˜ï¼Œå°±å¡«å…¥
        const savedToken = localStorage.getItem("asr_token");
        if (savedToken) {
            tokenInput.value = savedToken;
        }
        // ç”¨æˆ·æ¯æ¬¡ä¿®æ”¹ token å°±æ›´æ–°ç¼“å­˜
        tokenInput.addEventListener("input", () => {
            localStorage.setItem("asr_token", tokenInput.value.trim());
        });

        // ç›‘å¬å…¶ä»–å‚æ•°å˜æ›´
        document.getElementById("enableRealtimeTranslator")
            .addEventListener("change", params_change);
        document.getElementById("realtimeTranslatorTarget")
            .addEventListener("change", params_change);

        // æŒ‰é’®ç»‘å®š
        document.getElementById("btnStart").addEventListener("click", start);
        document.getElementById("btnStop").addEventListener("click", stop);
    };

    // åè®®å¤´æ„å»º
    function buildHeader(messageType, flags = 0, serialization = 1, compression = 0) {
        const version = 1;
        const headerSize = 1; // 4 å­—èŠ‚
        const byte0 = (version << 4) | headerSize;
        const byte1 = (messageType << 4) | flags;
        const byte2 = (serialization << 4) | compression;
        const byte3 = 0;
        return new Uint8Array([byte0, byte1, byte2, byte3]);
    }

    // æ•´åŒ…æ„å»º
    function buildPacket(messageType, payload, flags = 0, isJson = false) {
        const header = buildHeader(messageType, flags, isJson ? 1 : 0);
        const payloadBytes = isJson
            ? new TextEncoder().encode(JSON.stringify(payload))
            : payload;
        const sizeBytes = new Uint8Array(4);
        new DataView(sizeBytes.buffer).setUint32(0, payloadBytes.length, false);
        return new Blob([header, sizeBytes, payloadBytes]);
    }

    // åŠ¨æ€æ›´æ–°å‚æ•°
    function params_change() {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const config = {
            language: document.getElementById("languageSelect").value,
            enable_translator: document.getElementById("enableRealtimeTranslator").checked,
            translator_to_language: document.getElementById("realtimeTranslatorTarget").value,
        };
        ws.send(buildPacket(3, config, 0, true));
        console.log("å®æ—¶æ›´æ–°å‚æ•°åŒ…å·²å‘é€", config);
    }

    async function stop() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(buildPacket(4, {}, 0, true));
        }
    }

    async function start() {
        // å†æ¬¡ç¡®ä¿æœ€æ–° token å·²ç¼“å­˜
        const token = document.getElementById("token").value.trim();
        localStorage.setItem("asr_token", token);
        const userId = document.getElementById("userId").value.trim();
        if (!userId) {
            alert("è¯·è¾“å…¥ userId");
            return;
        }
        const reqId = Date.now().toString();
        ws = new WebSocket(
            `wss://recorder-test.iot.360.cn/v2/transcribe/realtime?reqId=${reqId}&src=iot_media&userId=${userId}`,
            ["chat", token]
        );
        ws.binaryType = "arraybuffer";

        const resultElem = document.getElementById("result");
        resultElem.innerText = ""; // æ¯æ¬¡å¯åŠ¨æ¸…ç©ºæ˜¾ç¤º

        ws.onmessage = (e) => {
            const buffer = new Uint8Array(e.data);
            const header = buffer.slice(0, 4);
            const payloadLen = new DataView(buffer.slice(4, 8).buffer)
                .getUint32(0, false);
            const payloadBytes = buffer.slice(8, 8 + payloadLen);

            const messageType = header[1] >> 4;
            const serializationMethod = header[2] >> 4;

            if ((messageType === 9 || messageType === 15) && serializationMethod === 1) {
                try {
                    const data = JSON.parse(new TextDecoder().decode(payloadBytes));
                    if (data.status === "realtime") {
                        resultElem.innerText += `ğŸ“ å®æ—¶è¯†åˆ«ç‰‡æ®µ: ${data.text}\n`;
                    } else if (data.status === "completed") {
                        resultElem.innerText += `âœ… æœ€ç»ˆè¯†åˆ«ç»“æœ: ${data.text}\n`;
                        if (data.segments) {
                            data.segments.forEach(seg => {
                                const speaker = seg.speaker || "æœªçŸ¥è¯´è¯äºº";
                                resultElem.innerText +=
                                    `ğŸ‘¤ ${speaker} [${seg.start.toFixed(2)}s - ${seg.end.toFixed(2)}s]: ${seg.text}\n`;
                            });
                        }
                    } else if (data.status === "success") {
                        resultElem.innerText += `ğŸ”— è¿æ¥æˆåŠŸ\n`;
                    } else {
                        resultElem.innerText += `ğŸ“¦ å…¶ä»–æ¶ˆæ¯: ${JSON.stringify(data)}\n`;
                    }
                } catch (err) {
                    console.error("è§£æé”™è¯¯:", err);
                }
            } else {
                console.warn("æ”¶åˆ°éé¢„æœŸæ¶ˆæ¯", { messageType, serializationMethod });
            }

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            resultElem.scrollTop = resultElem.scrollHeight;
        };

        ws.onopen = async () => {
            const config = {
                format: "pcm",
                language: document.getElementById("languageSelect").value,
                translator_to_language: document.getElementById("realtimeTranslatorTarget").value,
                transcribe_type: document.getElementById("transcribe_type").value,
                audio_format: { codec: "PCM", samplerate: 16000, channel: 1, bitdepth: 16 }
            };
            ws.send(buildPacket(1, config, 0, true));

            // å¼€å§‹é‡‡é›†å¹¶å‘é€éŸ³é¢‘
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const audioCtx = new AudioContext({ sampleRate: 16000 });
            const source = audioCtx.createMediaStreamSource(stream);
            const processor = audioCtx.createScriptProcessor(4096, 1, 1);
            const frameSize = Math.floor(audioCtx.sampleRate / FRAMES_PER_SECOND);

            processor.onaudioprocess = e => {
                const floatSamples = e.inputBuffer.getChannelData(0);
                const pcm = new Int16Array(floatSamples.length);
                for (let i = 0; i < floatSamples.length; i++) {
                    const s = Math.max(-1, Math.min(1, floatSamples[i]));
                    pcm[i] = s * 32767;
                }
                audioChunks.push(...pcm);
                while (audioChunks.length >= frameSize) {
                    const frame = audioChunks.splice(0, frameSize);
                    ws.send(buildPacket(2, new Uint8Array(new Int16Array(frame).buffer)));
                }
            };

            source.connect(processor);
            processor.connect(audioCtx.destination);
        };
    }
</script>
</body>
</html>
